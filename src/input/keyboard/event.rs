//! Keyboard events sent to this process by Windows as strongly-typed and safe
//! Rust representations.

use ::deku::prelude::*;
use ::widestring::WideChar;
use ::windows::Win32::{
    Foundation::LPARAM,
    UI::WindowsAndMessaging::{WM_CHAR, WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP},
};

use crate::{input::keyboard::KeyCode, window::WindowsProcessMessage};

/// Low-level representation of Win32 key events sent to this process.
///
/// <p style="background:rgba(255,181,77,0.16);padding:0.75em;">
/// <strong>Warning:</strong> This type is public for advanced use only.
/// </p>
///
/// Normally, you should use the [`keyboard`] object for state and text input
/// handling, but the [`KeyEvent`] type may be helpful if you are doing your
/// own event handling and not relying on a [`Window`] to automatically handle
/// the Windows process messages.
///
/// [`KeyEvent`]s are constructed from [`WindowsProcessMessage`]s and are
/// provided to the [`Keyboard`] which tracks state over time.
///
/// [`Window`]: crate::window::Window
/// [`Keyboard`]: crate::input::keyboard::Keyboard
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum KeyEvent {
    /// A key-down event. This might be the first key down event for a virtual
    /// key, or it could be a repeat event generated by holding down a key
    /// long enough for the key repeat to kick in.
    ///
    /// This event should _not_ be used for managing text input. Modern text
    /// input is too complicated to handle via virtual key codes. See the
    /// [`Keyboard`] object for help managing text input.
    ///
    /// [`Keyboard`]: crate::input::keyboard::Keyboard
    KeyDown {
        /// The virtual key code which was pressed.
        key_code: KeyCode,
        /// Keystroke flags which apply to all key events in Microsoft Windows.
        flags: KeystrokeFlags,
    },
    /// A key-up event. This event indicates a key was released.
    ///
    /// This event should _not_ be used for managing text input. Modern text
    /// input is too complicated to handle via virtual key codes. See the
    /// [`Keyboard`] object for help managing text input.
    ///
    /// [`Keyboard`]: crate::input::keyboard::Keyboard
    KeyUp {
        /// The virtual key code which was released.
        key_code: KeyCode,
        /// Keystroke flags which apply to all key events in Microsoft Windows.
        flags: KeystrokeFlags,
    },
    /// A text input event. These events can come from the physical keyboard, or
    /// be synthesized by virtual keyboards and alternate input mechanisms like
    /// the emoji/special character input panel.
    ///
    /// This event should _not_ be used for managing text input. Modern text
    /// input is too complicated to handle via virtual key codes. See the
    /// [`Keyboard`] object for help managing text input.
    ///
    /// [`Keyboard`]: crate::input::keyboard::Keyboard
    Input {
        /// The raw UTF-16 character. This might be an upper or lower surrogate
        /// pair, or even invalid unicode, so great care should be taken if you
        /// operate on this raw value.
        ///
        /// See the [`Keyboard`] object for the recommended way to handle user
        /// text input.
        ///
        /// [`Keyboard`]: crate::input::keyboard::Keyboard
        wchar: WideChar,
        /// Keystroke flags which apply to all key events in Microsoft Windows.
        flags: KeystrokeFlags,
    },
}

impl KeyEvent {
    /// Constructs [KeyEvent] from a [`WindowsProcessMessage`], if possible, and
    /// if the input message was a key event.
    ///
    /// This function should only be called if [`is_key_event()`] indicated that
    /// the message is a key event which could be handled by this type.
    ///
    /// [`is_key_event()`]: Self::is_key_event
    pub fn new(msg: WindowsProcessMessage) -> Option<Self> {
        match msg.identifier() {
            WM_KEYDOWN | WM_SYSKEYDOWN => {
                KeyCode::try_from(msg.wparam())
                    .ok()
                    .map(|key_code| Self::KeyDown {
                        key_code,
                        flags: msg.lparam().into(),
                    })
            }
            WM_KEYUP | WM_SYSKEYUP => {
                KeyCode::try_from(msg.wparam())
                    .ok()
                    .map(|key_code| Self::KeyUp {
                        key_code,
                        flags: msg.lparam().into(),
                    })
            }
            WM_CHAR => Some(Self::Input {
                wchar: msg.wparam() as u16,
                flags: msg.lparam().into(),
            }),
            _ => None,
        }
    }

    /// Indicates whether the given [`WindowsProcessMessage`] is a key event.
    ///
    /// If the message contains a key event, it is possible to convert the
    /// message into a [`KeyEvent`] by passing it to the [`KeyEvent::new`]
    /// constructor.
    pub const fn is_key_event(msg: WindowsProcessMessage) -> bool {
        matches!(
            msg.identifier(),
            WM_KEYDOWN | WM_SYSKEYDOWN | WM_KEYUP | WM_SYSKEYUP | WM_CHAR
        )
    }
}

/// The universal, low-level keystroke flags which accompany all Windows key
/// events.
///
/// <p style="background:rgba(255,181,77,0.16);padding:0.75em;">
/// <strong>Warning:</strong> This type is public for advanced use only.
/// </p>
///
/// Normally, you should use the [`keyboard`] object for state and text input
/// handling, but the [`KeystrokeFlags`] may be helpful if you are doing your
/// own event handling and not relying on a [`Window`] to automatically handle
/// the Windows process messages.
///
/// For help interpreting these flags, see MSDN documentation on [keystroke
/// message flags].
///
/// [`Window`]: crate::window::Window
/// [`Keyboard`]: crate::input::keyboard::Keyboard
/// [keystroke message flags]: https://learn.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input#keystroke-message-flags
#[derive(Clone, Copy, Debug, PartialEq, Eq, DekuRead, DekuWrite)]
#[deku(endian = "big")]
pub struct KeystrokeFlags {
    /// Bit 31. The transition state. The value is 1 if the key is being
    /// released, or it is 0 if the key is being pressed.
    #[deku(bits = "1")]
    pub(crate) is_key_release: bool,

    /// Bit 30. The previous key state. The value is 1 if the key is down
    /// before the message is sent, or it is 0 if the key is up.
    #[deku(bits = "1")]
    pub(crate) was_previous_state_down: bool,

    /// Bit 29. The context code.
    ///
    /// For a WM_KEYDOWN or WM_CHAR event, the value is 1 if the ALT key is held
    /// down while the key is pressed; otherwise, the value is 0.
    ///
    /// For a WM_KEYUP event, the value is always 0.
    #[deku(bits = "1")]
    pub(crate) is_alt_pressed: bool,

    /// Bit 24. Indicates whether the key is an extended key, such as the
    /// right-hand ALT and CTRL keys that appear on an enhanced 101- or
    /// 102-key keyboard. The value is 1 if it is an extended key;
    /// otherwise, it is 0.
    #[deku(pad_bits_before = "4", bits = "1")]
    pub(crate) is_extended_key: bool,

    /// Bits 16-23. The scan code. The value depends on the OEM.
    pub(crate) scan_code: u8,

    /// Bits 0-15. The repeat count for the current message. The value is
    /// the number of times the keystroke is auto-repeated as a
    /// result of the user holding down the key. If the keystroke is
    /// held long enough, multiple messages are sent. However, the
    /// repeat count is not cumulative.
    #[deku(bits = "16")]
    pub(crate) repeat_count: u16,
}

impl KeystrokeFlags {
    /// The transition state. The value is `true` if the key is being
    /// released, or it is `false` if the key is being pressed.
    pub const fn is_key_release(&self) -> bool {
        self.is_key_release
    }

    /// The previous key state. The value is `true` if the key is down
    /// before the message is sent, or it is `false` if the key is up.
    pub const fn was_previous_state_down(&self) -> bool {
        self.was_previous_state_down
    }

    /// The context code.
    ///
    /// For a `WM_KEYDOWN` or `WM_CHAR` event, the value is `true` if the ALT
    /// key is held down while the key is pressed; otherwise, the value is
    /// `false`. For a `WM_KEYUP` event, the value is always `false`.
    pub const fn is_alt_pressed(&self) -> bool {
        self.is_alt_pressed
    }

    /// Indicates whether the key is an extended key, such as the right-hand ALT
    /// and CTRL keys that appear on an enhanced 101- or 102-key keyboard. The
    /// value is `true` if it is an extended key; otherwise, it is `false`.
    pub const fn is_extended_key(&self) -> bool {
        self.is_extended_key
    }

    /// The scan code. This value depends on the OEM.
    pub const fn scan_code(&self) -> u8 {
        self.scan_code
    }

    /// The repeat count for the current message. The value is the number of
    /// times the keystroke is auto-repeated as a result of the user holding
    /// down the key. If the keystroke is held long enough, multiple messages
    /// are sent. The repeat count is not cumulative.
    pub const fn repeat_count(&self) -> u16 {
        self.repeat_count
    }
}

impl From<LPARAM> for KeystrokeFlags {
    fn from(lparam: LPARAM) -> Self {
        lparam.0.into()
    }
}

impl From<isize> for KeystrokeFlags {
    fn from(lparam: isize) -> Self {
        Self::from_bytes((&(lparam as u32).to_be_bytes(), 0))
            .unwrap()
            .1
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use ::pretty_assertions::assert_eq;

    /// Pressing 'h' without any modifiers.
    #[test]
    fn test_key_down() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_KEYDOWN,
            wparam: 0x48,
            lparam: 0x230001,
        })
        .unwrap();

        assert_eq!(
            event,
            KeyEvent::KeyDown {
                key_code: KeyCode::H,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: false,
                    was_previous_state_down: false,
                    is_key_release: false
                }
            }
        );
    }

    /// Char event emitted when pressing 'h';
    #[test]
    fn test_char_event() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_CHAR,
            wparam: 0x68,
            lparam: 0x230001,
        })
        .unwrap();

        assert_eq!(
            event,
            KeyEvent::Input {
                wchar: b'h' as u16,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: false,
                    was_previous_state_down: false,
                    is_key_release: false
                }
            }
        );
    }

    /// Test releasing 'h' without any modifiers.
    #[test]
    fn test_key_up() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_KEYUP,
            wparam: 0x48,
            lparam: 0xC0230001,
        })
        .expect("Valid KEYDOWN event should be parsed");

        assert_eq!(
            event,
            KeyEvent::KeyUp {
                key_code: KeyCode::H,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: false,
                    was_previous_state_down: true,
                    is_key_release: true,
                }
            }
        );
    }

    /// Pressing 'alt-h'.
    #[test]
    fn test_key_down_with_modifier() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_SYSKEYDOWN,
            wparam: 0x48,
            lparam: 0x20230001,
        })
        .unwrap();

        assert_eq!(
            event,
            KeyEvent::KeyDown {
                key_code: KeyCode::H,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: true,
                    was_previous_state_down: false,
                    is_key_release: false
                }
            }
        );
    }

    /// Test releasing 'alt-h'.
    #[test]
    fn test_key_up_with_modifiers() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_SYSKEYUP,
            wparam: 0x48,
            lparam: 0xE0230001,
        })
        .unwrap();

        assert_eq!(
            event,
            KeyEvent::KeyUp {
                key_code: KeyCode::H,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: true,
                    was_previous_state_down: true,
                    is_key_release: true,
                }
            }
        );
    }

    /// Pressing 'h' with key repeat.
    #[test]
    fn test_key_down_with_repeat() {
        // Event captured via `debug::DebugMsg` dump.
        let event = KeyEvent::new(WindowsProcessMessage {
            umsg: WM_KEYDOWN,
            wparam: 0x48,
            lparam: 0x40230001,
        })
        .unwrap();

        assert_eq!(
            event,
            KeyEvent::KeyDown {
                key_code: KeyCode::H,
                flags: KeystrokeFlags {
                    repeat_count: 1,
                    scan_code: 35,
                    is_extended_key: false,
                    is_alt_pressed: false,
                    was_previous_state_down: true,
                    is_key_release: false
                }
            }
        );
    }
}
